import {
  createSlice,
  createAsyncThunk,
  createSelector,
  createEntityAdapter,
} from '@reduxjs/toolkit'
import { client } from '../../api/client'

// воспользуемся функцией createEntityAdapter из поставки RTK
// Она позволяет нам нормализовать стейт за счёт того, что создаётся структура данных, которая позволяет каждую сущность
// хранить под своим уникальным ключом (вместо хранения сущности в массиве, что приводит к необходимости перебирать массив в поисках
// сущности по ID, а это в худшем случае может быть сложность O(n), что в принципе неплохо, но и неидеально). А также иметь отдельный
// массив с ID для упрощения отслеживания изменения количества сущностей (при удалении / добавлении сущностей).
// Такой формат хранения позволяет ускорить извлечение данных из стейта (O(1)) и избежать лишних рендеров.
const postsAdapter = createEntityAdapter({
  // в объекте должен быть ключ sortComparer и он должен быть функцией, которая умеет сортировать сущности (порядок сортировки мы определяем сами
  // - в данном случае мы как и раньше сортируем посты по дате)
  // эта функция и будет поддерживать массив с ID отсортированным!
  sortComparer: (a, b) => b.date.localeCompare(a.date),
})

// инициализируем начальный стейт в новой редакции с использованием функции getInitialState, которая генерирует объект вида {ids: [], entities: {}},
// а также принимает дополнительно объект, который описывает некую дополнительную структуру стейта (что-то, что нам дополнительно нужно)
const initialState = postsAdapter.getInitialState({
  status: 'idle',
  error: null,
})

// функция fetchPosts это thunk-creator
// мы создаём его с помощью встроенной функции createAsyncThunk, которая принимает 2 аргумента:
// 1) Строку, которая будет использоваться в качестве префикса при генерации типов в экшен-объектах
// 2) Коллбэк, который должен возвращать Promise (зарезолвленный / зареджектенный), на основе которого создаётся PAYLOAD
// в нашем случае мы видим, что в качестве коллбэка выступает асинхронная функция, результатом работы которой всегда будет Promise - то, что надо!
export const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {
  const response = await client.get('/fakeApi/posts')
  // нужно отдельно пояснить эту строчку
  // так как структура ответа с импровизированного бэка такая {data: []}, а нам нужен только массив постов,
  // то мы в payload-creator'е возвращаем промис, который резолвится сразу с массивом, а не со всем объектом с полем data (что нам не нужно)
  return response.data
})

// добавим ещё один асинхронный thunk-creator, только теперь для добавления нового поста
export const addNewPost = createAsyncThunk(
  'posts/addNewPost',
  // The payload creator receives the partial `{title, content, user}` object
  async (initialPost) => {
    // We send the initial data to the fake API server
    const response = await client.post('/fakeApi/posts', initialPost)
    // The response includes the complete post object, including unique ID
    return response.data
  }
)

// функция createSlice ожидает от нас объект, в котором будут:
// 1) Поле name, в котором мы зададим имя слайса. Это имя будет использоваться при формировании строкового значения
// поля type объекта action.
// 2) Начальный стейт, чтобы на момент старта приложения уже можно было что-то отрисовать в UI.
// 3) Поле reducers, в котором хранится объект со всеми локальными редьюсерами для обработки соотв. экшенов.
// Интересный момент: на основе идентификаторов, под которыми в коде будут числиться локальные редьюсеры,
// будут сгенерированы точно такие же экшен-криэйторы (имеется в виду с такими же идентификаторами) и также
// эти идентификаторы будут использоваться при формировании строкового значения поля type объекта action наравне с
// именем слайса (поле name).
// То есть в итоге в объекте экшена поле type формируется так: name + "/" + идентификатор соотв. экшен-криэйтора.
const postsSlice = createSlice({
  name: 'posts',
  initialState,
  reducers: {
    // здесь важно обратить внимание на то, что редьюсер postAdded написан по-другому, если сравнивать его с
    // редьюсером postUpdated. Если postUpdated внешне является простой функцией, которая принимает аргументы state и action.
    // То postAdded это уже объект! Такой формат написания редьюсеров в рамках RTK используется тогда, когда мы хотим
    // перенести подготовку объекта payload ИЗ React-компонента прямо В Redux. Для этого нам нужно добавить ещё функцию (смотри ниже)
    // postAdded: {
    //   reducer(state, action) {
    //     // одним из преимуществ RTK является то, что функция createSlice (а также createReducer) использует "под капотом"
    //     // библиотеку Immer(которая в свою очередь использует Proxy), которая позволяет нам писать логику обновления
    //     // стейта при помощи мутирующего синтаксиса (без спрэд-операторов и прочих приколов), но "за кулисами" обновление
    //     // стейта всё равно происходит БЕЗ мутирования (просто мы этого не видим).
    //     state.posts.push(action.payload)
    //   },
    //   // вот здесь и происходит добавление функции, которая занимается подготовкой объекта payload
    //   // здесь нужно обратить внимание на то, что это НЕ редьюсер! В отличие от редьюсеров это обычная функция! Она никак не работает со стейтом!
    //   // И следовательно она не обязана быть чистой! Именно поэтому мы совершенно не пугаясь добавляем прямо в функцию генератор ID.
    //   prepare(title, content, userId) {
    //     return {
    //       payload: {
    //         id: nanoid(),
    //         // нужно обратить внимание на то, что просто написать date: new Date() мы НЕ можем, хотя на первый взгляд
    //         // это будет экземпляр даты для конкретного момента времени, когда отработал экшен-криэйтор postAdded.
    //         // Объясняется это тем, что в Redux можно хранить только SERIALIZABLE данные, а new Date() по мнению
    //         // Redux - NON_SERIALIZABLE (спорный момент, если учесть, что у Date есть toJSON)
    //         date: new Date().toISOString(),
    //         title,
    //         content,
    //         user: userId,
    //         // ВАЖНО! Здесь забыл добавить объект с полями разных реакций на пост и счётчиками для каждой из них и попал на поиски бага на целый час.
    //         // Идея в том, что все свежесозданные объекты должны иметь поле reactions (оно потом "на местах" считывается для отрисовки кнопок реакций).
    //         // А так как сам редьюсер просто пушит payload в стейт, а payload мы практически целиком готовим в коллбэке prepare, то именно
    //         // здесь и нужно позаботиться о добавлении этого поля / свойства
    //         reactions: {
    //           thumbsUp: 0,
    //           hooray: 0,
    //           heart: 0,
    //           rocket: 0,
    //           eyes: 0,
    //         },
    //       },
    //     }
    //   },
    // },
    // добавим редьюсер на случай обновления поста
    postUpdated(state, action) {
      // можно было бы написать так и это было бы очень кратко и удобно:
      // state[action.payload.id] = action.payload
      // НО! Тогда у нас происходит по сути замена объекта и возможны лишние перерисовки, которые нам не нужны.
      // Поэтому мы возьмём существующий объект и точечно изменим только то, что меняется:
      const { id, title, content } = action.payload
      // это старая редакция (до нормализации) поиска поста
      // const postToEdit = state.posts.find((elem) => elem.id === id)

      // это новая редакция (после нормализации)
      const postToEdit = state.entities[id]
      if (postToEdit) {
        postToEdit.title = title
        postToEdit.content = content
      }
    },
    // добавим редьюсер на добавление реакции на пост
    reactionAdded(state, action) {
      const { postId, reaction } = action.payload
      // это старая редакция (до нормализации) поиска поста
      // const existingPost = state.posts.find((post) => post.id === postId)

      // это новая редакция (после нормализации)
      const existingPost = state.entities[postId]
      if (existingPost) {
        existingPost.reactions[reaction]++
      }
    },
  },
  // Важная фишка! Наряду с полем / свойством "reducers" нам нужно поле "extraReducers"
  // Зачем это надо? Дело в том, что когда мы описываем редьюсеры в объекте reducers, то функция createSlice берёт на себя
  // работу по генерации action-creator'ов. Но проблема в том, что когда мы идём в ОБРАТНОМ направлении - у нас УЖЕ есть action-creator'ы,
  // но ещё нет работающих с ними редьюсеров (а именно такая ситуация возникает когда мы используем функцию createAsyncThunk), -
  // то получается, что нам нужен какой-то способ для добавления редьюсеров под эти действия (иначе мы не сможем менять стейт)
  // extraReducers это и есть тот самый способ!
  extraReducers(builder) {
    // builder - это специальный объект, у которого есть разные методы (addCase, addMatcher, addDefaultCase)
    builder
      // здесь мы как раз используем метод addCase, который позволяет добавить редьюсер, который будет реагировать на конкретное
      // действие (в данном случае fetchPosts.pending). Это действие передаётся 1-ым аргументом, а вторым аргументом
      // передаётся по сути анонимный редьюсер - функция, которая принимает state и action, и что-то делает со стейтом
      .addCase(fetchPosts.pending, (state, action) => {
        state.status = 'loading'
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.status = 'succeeded'
        // старая редакция логики редьюсера по части добавления новых постов
        // state.posts = state.posts.concat(action.payload)

        // в новой редакции используется утилита upsertMany объекта postsAdapter, она позволяет "умно" смёрджить пришедшие изменения с тем, что есть
        postsAdapter.upsertMany(state, action.payload)
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.status = 'failed'
        state.error = action.error.message
      })
      // у адаптера есть ряд функций и мы можем использовать их в качестве редьюсеров
      // здесь, например, мы используем функцию addOne, которая судя по всему добавляет одну сущность
      .addCase(addNewPost.fulfilled, postsAdapter.addOne)
  },
})

// Функция createSlice одновременно с тем как мы добавляем редьюсер в объект reducers неявно создаёт
// экшен-криэйтор с точно таким же идентификатором (просто он хранится на другом объекте - slice.actions)
// "достаём" его из этого объекта и экспортируем, чтобы потом его использовать в UI
export const { postAdded, postUpdated, reactionAdded } = postsSlice.actions

// после создания слайса нам нужно экспортировать объект редьюсера,
// чтобы можно было в корневом редьюсере зайти в этот объект и по ссылкам непосредственно обратиться к функциям-редьюсерам
export default postsSlice.reducer

// до этого момента наши UI-компоненты получали нужные им данные с помощью хука useSelector и функций-селекторов, которые
// были написаны инлайново (то есть прямо по месту в хуке)
// тут есть 2 соображения:
// 1) представим кейс, когда у нас 10 разных компонентов получают одни и те же данные из глобального стейта,
// при инлайновых селекторах мы вынуждены в каждом компоненте раз за разом их писать
// 2) а теперь представим кейс, который является логическим продолжением предыдущего кейса:
// структура нашего глобального стейта поменялась и мы вынуждены "идти" в каждый из этих компонентов и переписывать
// код инлайновых-селекторов. а если таких компонентов 100? 1000? =(
// в общем решение довольно простое и очевидное: пишем функции-селекторы в соответствующих слайсах, импортируем их в UI.
// теперь если структура глобального стейта поменялась, то нам достаточно поменять функции-селекторы в слайсе и эти
// изменения сразу же отразятся в UI без необходимости фиксить каждый компонент

// ВАЖНЫЙ НЮАНС: state, который мы используем в этих функциях-селекторах ГЛОБАЛЬНЫЙ, а не локальный
// то есть если наш текущий слайс с постами в глобальном стейте достижим по ссылке state.posts, то мы так и пишем в селекторах
// это старая редакция некоторых селекторов
// export const selectAllPosts = (state) => state.posts.posts
// export const selectPostById = (state, postId) =>
//   state.posts.posts.find((post) => post.id === postId)

// новая редакция этих селекторов использует сгенерированные функцией адаптера getSelectors селекторы selectAll, selectById, selectIds
export const {
  // помимо ES6-деструктуризации мы здесь пользуемся возможностью задать новые наименования идентификаторов, чтобы нам не пришлось
  selectAll: selectAllPosts,
  selectById: selectPostById,
  selectIds: selectPostIds,
    // важно не забыть передать в getSelectors селектор, который извлечёт тот кусочек стейта, в котором хранится локальный слайс
} = postsAdapter.getSelectors(state => state.posts)

// Для начала поговорим немного о мемоизации в целом.
// Мемоизация в общем это такой процесс, при котором мы возвращаем уже посчитанный (как правило кэшированный) результат,
// когда входные данные те же самые. Это делается тогда, когда у нас есть какие-то ресурсоёмкие вычисления и нет никакого смысла
// считать по-новой то, что уже было вычислено на одном из предыдущих этапов.
// Если говорить о мемоизации в рамках функций-селекторов, то здесь речь идёт о том, что мы хотим возвращать старый результат, если
// часть глобального стейта, которую мы запрашиваем, не изменилась. Но проблема в том, что есть случаи когда глобальный стейт не меняется,
// но результатом работы функции-селектора является новая ссылка, например, на массив, так как функция-селектор использует, допустим, filter / map
// методы, которые при любом раскладе возвращают новую ссылку на массив. Значит, нам нужно эту проблему как-то решить. Нам поможет Reselect.

// создадим мемоизированную версию селектора постов по пользователю
// для этого воспользуемся функцией createSelector пакета reselect (правда, он теперь судя по всему встроен прямо в RTK)
// Эта функция принимает в качестве аргументов:
// 1) массив с любым количеством функций-селекторов.
// 2) "выходную" функцию-селектор, которая в свою очередь принимает в качестве аргументов результаты работы входных функций-селекторов
export const selectPostsByUser = createSelector(
  // вот массив с входными функциями-селекторами
  // здесь нужно обратить внимание на то, что ТЕ АРГУМЕНТЫ, С КОТОРЫМИ МЫ ВЫЗОВЕМ selectPostsByUser БУДУТ ПЕРЕДАНЫ ВО ВСЕ ВХОДНЫЕ СЕЛЕКТОРЫ,
  // А ЭТОЙ ИНФОРМАЦИИ Я НЕ ВИДЕЛ ДАЖЕ В ОФИЦИАЛЬНОЙ ДОКУМЕНТАЦИИ ПО RESELECT! (теперь понятно, почему были так написаны селекторы в проекте HREVENTS)
  // в принципе здесь по входным функциям-селекторам видно, что selectAllPosts от нас ожидает state, а вот второй селектор здесь
  // по сути ничего на самом деле не извлекает из глобального стейта! Он просто принимает эти аргументы и сразу же возвращает один из аргументов -
  // мы вынуждены так писать, так как такой интерфейс у createSelector и таким образом мы по сути описываем входные зависимости.
  [selectAllPosts, (state, userId) => userId],
  // вот выходная функция-селектор, которая будет возвращать новый результат только, если изменятся входные зависимости!
  // ещё один момент: аргументы выходного селектора могут быть названы как угодно, это просто плейсхолдеры
  (posts, userId) => posts.filter((post) => post.user === userId)
)
export const selectPostStatus = (state) => state.posts.status
export const selectPostError = (state) => state.posts.error

import {createSlice, nanoid} from '@reduxjs/toolkit' // импортируем функцию createSlice из RTK

// инициализируем начальный стейт
const initialState = [
  { id: '1', title: 'First Post!', content: 'Hello!' },
  { id: '2', title: 'Second Post', content: 'More text' },
]

// функция createSlice ожидает от нас объект, в котором будут:
// 1) Поле name, в котором мы зададим имя слайса. Это имя будет использоваться при формировании строкового значения
// поля type объекта action.
// 2) Начальный стейт, чтобы на момент старта приложения уже можно было что-то отрисовать в UI.
// 3) Поле reducers, в котором хранится объект со всеми локальными редьюсерами для обработки соотв. экшенов.
// Интересный момент: на основе идентификаторов, под которыми в коде будут числиться локальные редьюсеры,
// будут сгенерированы точно такие же экшен-криэйторы (имеется в виду с такими же идентификаторами) и также
// эти идентификаторы будут использоваться при формировании строкового значения поля type объекта action наравне с
// именем слайса (поле name).
// То есть в итоге в объекте экшена поле type формируется так: name + "/" + идентификатор соотв. экшен-криэйтора.
const postsSlice = createSlice({
  name: 'posts',
  initialState,
  reducers: {
    // здесь важно обратить внимание на то, что редьюсер postAdded написан по-другому, если сравнивать его с
    // редьюсером postUpdated. Если postUpdated внешне является простой функцией, которая принимает аргументы state и action.
    // То postAdded это уже объект! Такой формат написания редьюсеров в рамках RTK используется тогда, когда мы хотим
    // перенести подготовку объекта payload ИЗ React-компонента прямо В Redux. Для этого нам нужно добавить ещё функцию (смотри ниже)
    postAdded: {
      reducer(state, action) {
        // одним из преимуществ RTK является то, что функция createSlice (а также createReducer) использует "под капотом"
        // библиотеку Immer(которая в свою очередь использует Proxy), которая позволяет нам писать логику обновления
        // стейта при помощи мутирующего синтаксиса (без спрэд-операторов и прочих приколов), но "за кулисами" обновление
        // стейта всё равно происходит БЕЗ мутирования (просто мы этого не видим).
        state.push(action.payload)
      },
      // вот здесь и происходит добавление функции, которая занимается подготовкой объекта payload
      // здесь нужно обратить внимание на то, что это НЕ редьюсер! В отличие от редьюсеров это обычная функция! Она никак не работает со стейтом!
      // И следовательно она не обязана быть чистой! Именно поэтому мы совершенно не пугаясь добавляем прямо в функцию генератор ID.
      prepare(title, content) {
        return {
          payload: {
            id: nanoid(),
            title,
            content
          }
        }
      }
    },
    // добавим редьюсер на случай обновления поста
    postUpdated(state, action) {
      // можно было бы написать так и это было бы очень кратко и удобно:
      // state[action.payload.id] = action.payload
      // НО! Тогда у нас происходит по сути замена объекта и возможны лишние перерисовки, которые нам не нужны.
      // Поэтому мы возьмём существующий объект и точечно изменим только то, что меняется:
      const { id, title, content } = action.payload
      const postToEdit = state.find((elem) => elem.id === id)
      if (postToEdit) {
        postToEdit.title = title
        postToEdit.content = content
      }
    },
  },
})

// Функция createSlice одновременно с тем как мы добавляем редьюсер в объект reducers неявно создаёт
// экшен-криэйтор с точно таким же идентификатором (просто он хранится на другом объекте - slice.actions)
// "достаём" его из этого объекта и экспортируем, чтобы потом его использовать в UI
export const { postAdded, postUpdated } = postsSlice.actions

// после создания слайса нам нужно экспортировать объект редьюсера,
// чтобы можно было в корневом редьюсере зайти в этот объект и по ссылкам непосредственно обратиться к функциям-редьюсерам
export default postsSlice.reducer
